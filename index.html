<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Omi</title>
  <meta name="description" content="Omi - write without visual distractions">
  <meta name="theme-color" content="#ffffff">
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <!-- Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Geist:wght@400;700&family=Instrument+Serif&family=Geist+Mono&family=Monrope&family=PP+Neue+Machina&display=swap">
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: var(--bg, #f7f7f8);
      color: var(--fg, #222);
      font-family: 'Geist', 'Inter', sans-serif;
      width: 100vw;
      height: 100vh;
      transition: background 0.2s, color 0.2s;
    }
    body {
      min-height: 100vh;
      min-width: 100vw;
      overflow: hidden;
    }
    #editor {
      outline: none;
      border: none;
      width: 100vw;
      height: 100vh;
      padding: 5vh 10vw;
      box-sizing: border-box;
      font-size: 1.25rem;
      background: transparent;
      line-height: 1.7;
      resize: none;
      color: inherit;
      font-family: inherit;
      transition: background 0.2s, color 0.2s;
      /* Show default caret as fallback */
      caret-color: var(--fg, #222);
      position: relative;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: rgba(0,0,0,0.15) transparent;
    }
    #editor.scrolling {
      scrollbar-color: rgba(0,0,0,0.4) transparent;
    }
    #editor::-webkit-scrollbar {
      width: 8px;
    }
    #editor::-webkit-scrollbar-button {
      display: none;
      width: 0;
      height: 0;
    }
    #editor::-webkit-scrollbar-thumb {
      background: rgba(0,0,0,0.15);
      border-radius: 4px;
      transition: background 0.8s;
    }
    #editor.scrolling::-webkit-scrollbar-thumb,
    #editor:hover::-webkit-scrollbar-thumb {
      background: rgba(0,0,0,0.4);
    }
    body[data-theme="dark"] #editor,
    body[data-theme="night"] #editor {
      scrollbar-color: rgba(255,255,255,0.15) transparent;
    }
    body[data-theme="dark"] #editor.scrolling,
    body[data-theme="night"] #editor.scrolling {
      scrollbar-color: rgba(255,255,255,0.4) transparent;
    }
    body[data-theme="dark"] #editor::-webkit-scrollbar-thumb,
    body[data-theme="night"] #editor::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.15);
    }
    body[data-theme="dark"] #editor.scrolling::-webkit-scrollbar-thumb,
    body[data-theme="night"] #editor.scrolling::-webkit-scrollbar-thumb,
    body[data-theme="dark"] #editor:hover::-webkit-scrollbar-thumb,
    body[data-theme="night"] #editor:hover::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.4);
    }
    #editor.mac-caret-active {
      caret-color: transparent;
    }
    #editor.mac-caret-active::after {
      content: '';
      display: block;
      position: fixed;
      width: 3px;
      height: var(--mac-caret-height, 1.25em);
      border-radius: 1.5px;
      background: var(--mac-caret-color, #222);
      z-index: 10010;
      pointer-events: none;
      left: var(--mac-caret-x, -1000px);
      top: var(--mac-caret-y, -1000px);
      animation: var(--caret-animation, mac-caret-blink 1.1s cubic-bezier(.4,0,.2,1) infinite);
      opacity: 1;
      will-change: opacity, left, top, height;
    }
    #editor.mac-caret-active.slow-blink::after {
      animation: mac-caret-slow-blink 2.4s cubic-bezier(.4,0,.2,1) infinite;
    }
    @keyframes mac-caret-blink {
      0% { opacity: 1; }
      60% { opacity: 1; }
      70% { opacity: 0; }
      100% { opacity: 0; }
    }
    @keyframes mac-caret-slow-blink {
      0% { opacity: 1; }
      85% { opacity: 1; }
      100% { opacity: 0; }
    }
    body[data-theme="dark"] #editor.mac-caret-active::after,
    body[data-theme="night"] #editor.mac-caret-active::after {
      background: #fff;
    }
    /* Make links more visible in dark and night mode */
    body[data-theme="dark"] a,
    body[data-theme="night"] a {
      color: #7ecbff;
      text-decoration-color: #7ecbff;
    }
    /* Theme variables */
    :root {
      --bg: #f7f7f8;
      --fg: #222;
      --menu-bg: #fff;
    }
    body[data-theme="dark"] {
      --bg: #18181b;
      --fg: #f7f7f8;
      --menu-bg: #232329;
    }
    body[data-theme="night"] {
      --bg: #101014;
      --fg: #c3c3e5;
      --menu-bg: #18181b;
    }
    body[data-theme="dark"] #command-menu button:hover,
    body[data-theme="night"] #command-menu button:hover {
      background: #232329;
    }
    input[type="checkbox"] {
      transform: scale(1.2);
      margin-right: 0.5em;
      vertical-align: middle;
    }
    #editor.empty:before {
      content: attr(data-placeholder);
      color: #aaa;
      pointer-events: none;
      position: absolute;
      left: 10vw;
      top: 5vh;
      font-size: 1.25rem;
      font-family: inherit;
      opacity: 0.6;
    }
    #word-count {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 1.5vh;
      text-align: center;
      color: #aaa;
      font-size: 0.95rem;
      font-family: inherit;
      pointer-events: none;
      user-select: none;
      letter-spacing: 0.01em;
    }
    a {
      text-decoration: underline;
      text-decoration-color: #b3b3b3;
      text-underline-offset: 2px;
      /* Remove red underline from spellcheck */
      -webkit-text-decoration-skip: none;
      text-decoration-skip-ink: none;
      /* Remove red squiggle in some browsers */
      spellcheck: false;
    }
    a[spellcheck="false"] {
      /* Remove red underline for links */
      text-decoration: underline;
      text-decoration-color: #b3b3b3;
      text-underline-offset: 2px;
      -webkit-text-decoration-skip: none;
      text-decoration-skip-ink: none;
    }
    #copyDropdown {
      position: absolute;
      background: var(--menu-bg, white);
      border-radius: 8px;
      padding: 0.5rem 0;
      display: none;
      z-index: 1000;
      min-width: 200px;
      box-shadow: none;
      margin-top: 5px;
    }
    #highlight-picker {
      position: absolute;
      display: none;
      background: var(--menu-bg, white);
      padding: 0.5em;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      gap: 4px;
      z-index: 100010;
    }
    #highlight-picker span {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      cursor: pointer;
      border: 1px solid rgba(0,0,0,0.2);
    }
    body[data-theme="dark"] #highlight-picker span,
    body[data-theme="night"] #highlight-picker span {
      border-color: rgba(255,255,255,0.2);
    }
    .option {
      padding: 0.5rem 1rem;
      cursor: pointer;
    }
    .option:hover {
      background: #f0f0f0;
    }
    .option.selected {
      background: #e0e0e0; /* Highlight selected option */
    }
    #toast {
      position: fixed;
      bottom: 1.5vh;
      left: 1vw;
      color: #aaa;
      font-size: 0.9rem;
      display: none;
      z-index: 9999;
    }
    .snapshotItem {
      padding: 0.5rem 1rem; /* Add padding for better click area */
      transition: background 0.2s; /* Smooth background transition */
    }
    .snapshotItem:hover {
      background: #f0f0f0; /* Light background on hover */
    }
    .snapshotItem:focus {
      outline: none; /* Remove default outline */
      background: #e0e0e0; /* Highlight on focus */
    }

    .image-block {
      display: inline-block;
      text-align: center;
      margin: 0.5em 0;
    }
    .image-block img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 0 auto;
    }
    .pdf-block {
      margin: 0.5em 0;
      display: block;
    }
    .pdf-block embed {
      width: 100%;
      height: 500px;
    }
    .resizable {
      display: inline-block;
      position: relative;
    }
    .resize-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      background: rgba(0,0,0,0.4);
      border-radius: 2px;
      user-select: none;
    }
    .resize-handle[data-dir="nw"] { left: 0; top: 0; cursor: nwse-resize; }
    .resize-handle[data-dir="ne"] { right: 0; top: 0; cursor: nesw-resize; }
    .resize-handle[data-dir="sw"] { left: 0; bottom: 0; cursor: nesw-resize; }
    .resize-handle[data-dir="se"] { right: 0; bottom: 0; cursor: nwse-resize; }
    .image-comment {
      font-size: 0.9rem;
      color: #666;
      font-style: italic;
    }
    .image-comment:empty:before {
      content: attr(data-placeholder);
      color: #aaa;
    }
    body.layout-blog #editor {
      max-width: 40em;
      margin: 0 auto;
    }
    body.layout-newsletter #editor {
      max-width: 600px;
      margin: 0 auto;
      font-size: 1.1rem;
    }
    body.layout-ebook #editor {
      max-width: 550px;
      margin: 0 auto;
      font-family: 'Times New Roman', serif;
      line-height: 1.6;
    }
    #caretRipple {
      position: fixed;
      pointer-events: none;
      border-radius: 50%;
      background: rgba(0,0,0,0.4);
      width: 0;
      height: 0;
      opacity: 0;
      transform: translate(-50%, -50%);
      z-index: 10004;
    }
    body[data-theme="dark"] #caretRipple,
    body[data-theme="night"] #caretRipple {
      background: rgba(255,255,255,0.5);
    }
    @keyframes ripple {
      from { width:0; height:0; opacity:0.6; }
      to { width:40px; height:40px; opacity:0; }
    }
    .ripple-animate {
      animation: ripple 0.8s ease-out;
    }

    .memory-label {
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: auto;
    }
    .memory-label:hover {
      opacity: 0.4;
    }
    body.typewriter-mode #editor {
      overflow-y: auto;
      padding-top: 40vh;
      padding-bottom: 40vh;
      box-sizing: border-box;
    }

    /* Current line highlight */
    body.line-highlight::before {
      content: '';
      position: fixed;
      left: 0;
      width: 100vw;
      height: var(--mac-caret-height, 1.4em);
      top: calc(var(--mac-caret-y, -1000px) - 2px);
      background: rgba(0,0,0,0.1);
      pointer-events: none;
      z-index: 10005;
    }
    #slashSuggestions{position:absolute;display:none;list-style:none;margin:0;padding:0.3em 0;background:var(--menu-bg,white);border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.15);z-index:10005;font-size:0.95em;}
    #slashSuggestions li{padding:0.2em 0.8em;cursor:pointer;white-space:nowrap;}
    #slashSuggestions li:hover{background:rgba(0,0,0,0.05);}
    body[data-theme="dark"] #slashSuggestions li:hover,
    body[data-theme="night"] #slashSuggestions li:hover{background:#232329;color:#fff;}
    body[data-theme="dark"].line-highlight::before,
    body[data-theme="night"].line-highlight::before {
      background: rgba(255,255,255,0.08);

    }
  </style>
</head>
<body>
  <div id="editor" contenteditable="true" spellcheck="true" aria-label="Omi" data-placeholder="Start writing..."></div>
  <ul id="slashSuggestions" class="hidden"></ul>
  <div id="word-count"></div>
  <div id="bottom-right" style="position:fixed;right:1vw;bottom:1.5vh;display:flex;gap:0.5em;align-items:center;color:#aaa;font-size:0.95rem;font-family:inherit;z-index:10001;">
    <div id="font-switcher" style="user-select:none;cursor:pointer;">Geist</div>
    <div id="timer-minimal" style="pointer-events:none;user-select:none;letter-spacing:0.01em;display:none;"></div>
  </div>
  <div id="active-commands" style="position:fixed;left:1vw;bottom:1.5vh;z-index:10002;color:#aaa;font-size:0.95rem;font-family:inherit;user-select:none;pointer-events:none;text-align:left;"></div>
  <div id="stats-minimal" style="position:fixed;left:1vw;bottom:4.5vh;z-index:10003;color:#aaa;font-size:0.95rem;font-family:inherit;user-select:none;pointer-events:none;text-align:left;display:none;"></div>
  <div id="zen-overlay" style="display:none;position:fixed;z-index:99999;top:0;left:0;width:100vw;height:100vh;background:rgba(255,255,255,0.7);"></div>
  <div id="timer-box" style="display:none;position:fixed;top:2vh;right:2vw;z-index:10000;background:rgba(30,30,40,0.92);color:#fff;padding:0.7em 1.3em;border-radius:8px;font-size:1.2rem;font-family:inherit;box-shadow:0 2px 12px rgba(0,0,0,0.12);"></div>
  <div id="stats-modal" style="display:none;position:fixed;z-index:10001;top:50%;left:50%;transform:translate(-50%,-50%);background:#fff;color:#222;padding:2em 2.5em;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.18);font-family:inherit;min-width:260px;max-width:90vw;"></div>
  <div id="link-tooltip" style="display:none;position:fixed;z-index:99999;"></div>
  <div id="copyDropdown"></div>
  <div id="toast"></div>
  <div id="caretRipple"></div>
  <div id="highlight-picker"></div>
  <div id="command-help-btn" style="position:fixed;right:1vw;top:1.5vh;bottom:auto;color:#aaa;font-size:0.95rem;font-family:inherit;user-select:none;cursor:pointer;z-index:10001;">Commands</div>
  <div id="command-help-modal" style="display:none;position:fixed;z-index:10002;top:5vh;right:1vw;left:auto;transform:none;background:#fff;color:#222;padding:1.5em 2em;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.18);font-family:inherit;min-width:260px;max-width:90vw;"></div>
  <script>
    const SNAPSHOT_KEY = "omi-snapshots"; // Define the key for storing snapshots
    const editor = document.getElementById('editor');
    const menu = document.getElementById('command-menu');
    let selectionRange = null;
    let themeCycle = ['light', 'dark', 'night'];
    const slashSuggestions = document.getElementById("slashSuggestions");
    const fontSwitcher = document.getElementById('font-switcher');
    const fonts = ['Instrument Serif', 'Geist Mono', 'Monrope', 'PP Neue'];
    let currentFont = localStorage.getItem('omi-font') || 'Geist';
    function setFont(font) {
      currentFont = font;
      document.body.style.fontFamily = `'${font}', 'Inter', sans-serif`;
      fontSwitcher.textContent = font;
      localStorage.setItem('omi-font', font);
    }
    setFont(currentFont);
    function setLayout(layout) {
      document.body.classList.remove('layout-blog','layout-newsletter','layout-ebook');
      if (layout) document.body.classList.add('layout-' + layout);
      localStorage.setItem('omi-layout', layout);
    }
    const savedLayout = localStorage.getItem('omi-layout');
    if (savedLayout) setLayout(savedLayout);
    fontSwitcher.addEventListener('click', () => {
      const font = fonts[Math.floor(Math.random() * fonts.length)];
      setFont(font);
    });

    // Load from localStorage
    editor.innerHTML = localStorage.getItem('omi-content') || '';
    editor.querySelectorAll('img.resizable, embed.resizable').forEach(makeImageResizable);
    autoLink(editor);
    autoMarkdown(editor);
    autoHeading();
    autoMemoryLabels(editor);
    const savedTheme = localStorage.getItem('omi-theme') || 'light';
    document.body.setAttribute('data-theme', savedTheme);

    // Auto-save to localStorage
    editor.addEventListener('input', () => {
      localStorage.setItem('omi-content', editor.innerHTML);
    });
    // Persist checkbox state
    editor.addEventListener('change', (e) => {
      if (e.target.type === 'checkbox') {
        if (e.target.checked) {
          e.target.setAttribute('checked', '');
        } else {
          e.target.removeAttribute('checked');
        }
        localStorage.setItem('omi-content', editor.innerHTML);
      }
    });

    // Drag & drop for images and PDFs
    editor.addEventListener('dragover', e => e.preventDefault());
    editor.addEventListener('drop', e => {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      if (!file) return;
      if (file.type.startsWith('image/')) {
        insertImageFile(file);
      } else if (file.type === 'application/pdf') {
        insertPdfFile(file);
      }
    });

    // Dim scrollbar when idle
    let scrollTimeout;
    editor.addEventListener('scroll', () => {
      editor.classList.add('scrolling');
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        editor.classList.remove('scrolling');
      }, 1500);
    });

    // Save theme
    function setTheme(theme) {
      document.body.setAttribute('data-theme', theme);
      localStorage.setItem('omi-theme', theme);
    }

    // Helper: get selection rect
    function getSelectionRect() {
      const sel = window.getSelection();
      if (!sel.rangeCount) return null;
      const range = sel.getRangeAt(0).cloneRange();
      const rect = range.getClientRects()[0];
      return rect || null;
    }

    // Command Bar JS

    // Replace [] with checkbox when typed
    editor.addEventListener('input', (e) => {
      // Only run if last 2 chars are []
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      const range = sel.getRangeAt(0);
      const node = range.startContainer;
      if (node.nodeType === 3) { // text node
        let text = node.textContent;
        if (text && text.endsWith('[]')) {
          // Replace [] with checkbox
          const newText = text.slice(0, -2);
          node.textContent = newText;
          // Insert checkbox
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          range.setStart(node, newText.length);
          range.collapse(true);
          range.insertNode(checkbox);
          // Move caret after checkbox
          const space = document.createTextNode(' ');
          checkbox.after(space);
          range.setStartAfter(space);
          range.collapse(true);
          sel.removeAllRanges();
          sel.addRange(range);
          // Save to localStorage
          localStorage.setItem('omi-content', editor.innerHTML);
        }
      }
      // Auto-link URLs as you type
      autoLink(editor);
      // Inline Markdown as you type
      autoMarkdown(editor);
      autoHeading();
      autoMemoryLabels(editor);
      // Placeholder
      updatePlaceholder();
    });

    // Auto-link URLs in the editor
    function autoLink(container) {
      const urlRegex = /(https?:\/\/[\w\-._~:/?#[\]@!$&'()*+,;=%]+)/g;
      function processNode(node) {
        if (node.nodeType === 3) { // text node
          let text = node.textContent;
          if (urlRegex.test(text)) {
            const frag = document.createDocumentFragment();
            let lastIndex = 0;
            text.replace(urlRegex, (url, match, offset) => {
              if (offset > lastIndex) {
                frag.appendChild(document.createTextNode(text.slice(lastIndex, offset)));
              }
              const a = document.createElement('a');
              a.href = url;
              a.textContent = url;
              a.target = '_blank';
              a.setAttribute('spellcheck', 'false');
              frag.appendChild(a);
              lastIndex = offset + url.length;
            });
            if (lastIndex < text.length) {
              frag.appendChild(document.createTextNode(text.slice(lastIndex)));
            }
            node.replaceWith(frag);
          }
        } else if (node.nodeType === 1 && node.childNodes && node.tagName !== 'A') {
          // Don't process inside links
          for (let i = node.childNodes.length - 1; i >= 0; i--) {
            processNode(node.childNodes[i]);
          }
        }
      }
      processNode(container);
      // Set spellcheck=false on all links (in case of pasted HTML)
      container.querySelectorAll('a').forEach(a => a.setAttribute('spellcheck', 'false'));
    }


    // Inline Markdown support: **bold**, *italic*, ~~strike~~, __underline__, `code`
    function autoMarkdown(container) {
      function processNode(node) {
        if (node.nodeType === 3) { // text node
          let text = node.textContent;
          let changed = false;
          const rules = [
            {regex: /\*\*([^*]+)\*\*/g, tag: 'b'},
            {regex: /\*([^*]+)\*/g, tag: 'i'},
            {regex: /~~([^~]+)~~/g, tag: 'del'},
            {regex: /__([^_]+)__/g, tag: 'u'},
            {regex: /`([^`]+)`/g, tag: 'code'}
          ];
          rules.forEach(r => {
            text = text.replace(r.regex, (m, p1) => {
              changed = true;
              return `\u0000${r.tag}\u0000${p1}\u0000/${r.tag}\u0000`;
            });
          });
          if (changed) {
            // Replace with HTML nodes
            let frag = document.createDocumentFragment();
            let parts = text.split(/\u0000/).filter(Boolean);
            let stack = [];
            for (let part of parts) {
              if (['b','i','del','u','code'].includes(part)) {
                let el = document.createElement(part);
                stack.push(el);
              } else if (part.startsWith('/')) {
                let el = stack.pop();
                if (stack.length > 0) {
                  stack[stack.length - 1].appendChild(el);
                } else {
                  frag.appendChild(el);
                }
              } else if (part) {
                if (stack.length > 0) {
                  stack[stack.length - 1].appendChild(document.createTextNode(part));
                } else {
                  frag.appendChild(document.createTextNode(part));
                }
              }
            }
            node.replaceWith(frag);
          }
        } else if (node.nodeType === 1 && node.childNodes && !['B','I','DEL','U','CODE'].includes(node.tagName)) {
          for (let i = node.childNodes.length - 1; i >= 0; i--) {
            processNode(node.childNodes[i]);
          }
        }
      }
      processNode(container);
    }

    // Convert '# ' to headings on the current line
    function autoHeading() {
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      const range = sel.getRangeAt(0);
      let block = range.startContainer;
      while (block && block !== editor && !/^(P|DIV|H[1-6])$/.test(block.nodeName)) {
        block = block.parentElement;
      }
      if (!block || block === editor) return;
      const text = block.innerText || block.textContent;
      const match = text.match(/^(#{1,6})\s/);
      if (match) {
        const level = match[1].length;
        const content = text.slice(level + 1);
        const h = document.createElement('h' + level);
        h.innerHTML = content || '<br>';
        block.replaceWith(h);
        const newRange = document.createRange();
        newRange.setStart(h, 0);
        newRange.collapse(true);
        sel.removeAllRanges();
        sel.addRange(newRange);
      }
    }

    // Convert [[label]] to invisible memory labels
    function autoMemoryLabels(container) {
      const labelRegex = /\[\[([^\]]+)\]\]/g;
      function processNode(node) {
        if (node.nodeType === 3) {
          let text = node.textContent;
          if (labelRegex.test(text)) {
            const frag = document.createDocumentFragment();
            let last = 0;
            text.replace(labelRegex, (m, label, offset) => {
              if (offset > last) {
                frag.appendChild(document.createTextNode(text.slice(last, offset)));
              }
              const span = document.createElement('span');
              span.className = 'memory-label';
              span.dataset.label = label;
              span.textContent = label;
              frag.appendChild(span);
              last = offset + m.length;
            });
            if (last < text.length) {
              frag.appendChild(document.createTextNode(text.slice(last)));
            }
            node.replaceWith(frag);
          }
        } else if (node.nodeType === 1 && node.childNodes) {
          for (let i = node.childNodes.length - 1; i >= 0; i--) {
            processNode(node.childNodes[i]);
          }
        }
      }
      processNode(container);
    }

    // Placeholder logic
    function updatePlaceholder() {
      if (editor.innerText.trim() === '') {
        editor.classList.add('empty');
      } else {
        editor.classList.remove('empty');
      }
    }
    updatePlaceholder();
    editor.addEventListener('focus', updatePlaceholder);
    editor.addEventListener('blur', updatePlaceholder);

    // Copy helper
    function copyContent() {
      const content = editor.innerHTML; // Get the current content of the editor
      const format = 'Plain Text'; // You can modify this to allow format selection if needed

      if (format === "Plain Text") {
        const output = editor.innerText;
        navigator.clipboard.writeText(output).then(() => {
          showToast("Copied as Plain Text");
          removeSlashCommand('/copy'); // Remove the command from the editor
        }).catch(err => {
          console.error('Failed to copy: ', err);
        });
      } else if (format === "Markdown") {
        const output = toMarkdown(content);
        navigator.clipboard.writeText(output).then(() => {
          showToast("Copied as Markdown");
          removeSlashCommand('/copy'); // Remove the command from the editor
        }).catch(err => {
          console.error('Failed to copy: ', err);
        });
      } else if (format === "HTML") {
        navigator.clipboard.writeText(content).then(() => {
          showToast("Copied as HTML");
          removeSlashCommand('/copy'); // Remove the command from the editor
        }).catch(err => {
          console.error('Failed to copy: ', err);
        });
      } else if (format === "Rich Text") {
        const blob = new Blob([content], { type: "text/html" });
        const item = new ClipboardItem({ "text/html": blob });
        navigator.clipboard.write([item]).then(() => {
          showToast("Copied as Rich Text");
          removeSlashCommand('/copy'); // Remove the command from the editor
        }).catch(err => {
          console.error('Failed to copy: ', err);
        });
      }
    }

    // CMD/CTRL+M for theme mode
    editor.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'm') {
        e.preventDefault();
        let current = document.body.getAttribute('data-theme') || 'light';
        let idx = themeCycle.indexOf(current);
        let next = themeCycle[(idx + 1) % themeCycle.length];
        setTheme(next);
      }
    });

    // Exit image comments on Enter
    editor.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && e.target.classList.contains('image-comment')) {
        e.preventDefault();
        const container = e.target.closest('figure') || e.target;
        const p = document.createElement('p');
        p.innerHTML = '<br>';
        container.after(p);
        const range = document.createRange();
        range.setStart(p, 0);
        range.collapse(true);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
        updateWordCount();
        updatePlaceholder();
      }
    });

    // Double-click link to open in new tab
    editor.addEventListener('dblclick', (e) => {
      if (e.target.tagName === 'A') {
        window.open(e.target.href, '_blank');
      }
    });

    // Link hover tooltip with title and favicon
    const tooltip = document.getElementById('link-tooltip');
    let tooltipTimeout;
    editor.addEventListener('mouseover', async (e) => {
      if (e.target.tagName === 'A') {
        const link = e.target;
        tooltip.style.display = 'block';
        tooltip.style.left = (e.clientX + 12) + 'px';
        tooltip.style.top = (e.clientY + 12) + 'px';
        tooltip.innerHTML = 'Loading...';
        // Fetch title and favicon
        try {
          const url = new URL(link.href);
          const favicon = url.origin + '/favicon.ico';
          let title = link.href;
          // Try to fetch title (CORS may block)
          let gotTitle = false;
          try {
            const resp = await fetch('https://corsproxy.io/?' + encodeURIComponent(link.href));
            const text = await resp.text();
            const match = text.match(/<title>(.*?)<\/title>/i);
            if (match) {
              title = match[1];
              gotTitle = true;
            }
          } catch {}
          tooltip.innerHTML = `<img src="${favicon}" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"> <span>${title}</span>`;
        } catch {
          tooltip.innerHTML = link.href;
        }
      }
    });
    editor.addEventListener('mousemove', (e) => {
      if (e.target.tagName === 'A') {
        tooltip.style.left = (e.clientX + 12) + 'px';
        tooltip.style.top = (e.clientY + 12) + 'px';
      }
    });
    editor.addEventListener('mouseout', (e) => {
      if (e.target.tagName === 'A') {
        tooltip.style.display = 'none';
        tooltip.innerHTML = '';
      }
    });

    // Word and letter count
    const wordCountDiv = document.getElementById('word-count');
    const timerMinimal = document.getElementById('timer-minimal');
    const activeCommandsDiv = document.getElementById('active-commands');
    const statsMinimal = document.getElementById('stats-minimal');
    let activeCommands = [];
    function updateWordCount() {
      let text = editor.innerText.trim();
      let wordCount = text ? text.split(/\s+/).length : 0;
      let letterCount = text.replace(/\s+/g, '').length;
      wordCountDiv.textContent = `${wordCount === 1 ? '1 word' : wordCount + ' words'} • ${letterCount} letters`;
      // Save daily word count
      let today = new Date().toISOString().slice(0, 10);
      let dailyKey = 'omi-daily-' + today;
      localStorage.setItem(dailyKey, String(wordCount));
      updateStatsMinimal();
    }
    editor.addEventListener('input', updateWordCount);
    updateWordCount();

    // Slash commands
    editor.addEventListener('keydown', async (e) => {
      if (e.key === 'Enter') {
        const text = editor.innerText.trim();
        const cmdMatch = text.match(/\/(\w+)(?:\s+(.*))?$/);
        if (cmdMatch) {
          e.preventDefault();
          const cmd = cmdMatch[1];
          const arg = cmdMatch[2];
          switch (cmd) {
            case 'clear':
              clearEditorContent();
              removeSlashCommand('/clear');
              break;
            case 'clearx':
              clearAll();
              removeSlashCommand('/clearx');
              break;
            case 'copy':
              handleCopyCommand();
              removeSlashCommand('/copy');
              break;
            case 'load':
              loadSnapshots();
              removeSlashCommand('/load');
              break;
            case 'save':
              saveSnapshot();
              removeSlashCommand('/save');
              break;
            case 'export':
              exportContent();
              removeSlashCommand('/export');
              break;
            case 'history':
              showHistory();
              removeSlashCommand('/history');
              break;
            case 'image':
              openImageSelector();
              removeSlashCommand('/image');
              break;
            case 'pdf':
              openPdfSelector();
              removeSlashCommand('/pdf');
              break;
            case 'focus':
              document.body.classList.toggle('focus-mode');
              toggleActiveCommand('focus');
              removeSlashCommand('/focus');
              break;
            case 'typewriter':
              document.body.classList.toggle('typewriter-mode');
              toggleActiveCommand('typewriter');
              removeSlashCommand('/typewriter');
              break;
            case 'lines':
              document.body.classList.toggle('line-highlight');
              toggleActiveCommand('lines');
              removeSlashCommand('/lines');
              break;
            case 'font':
              const font = fonts[Math.floor(Math.random() * fonts.length)];
              setFont(font);
              removeSlashCommand('/font');
              break;
            case 'zen':
              toggleZenMode();
              toggleActiveCommand('zen');
              removeSlashCommand('/zen');
              break;
            case 'timer':
              if (arg === 'stop' || arg === '0') {
                stopTimer();
                toggleActiveCommand('timer', false);
              } else {
                let mins = parseInt(arg || '25', 10);
                if (!isNaN(mins) && mins > 0) startTimer(mins);
                toggleActiveCommand('timer', true, mins);
              }
              removeSlashCommand(/\/timer(\s+\d+|\s+stop|\s+0)?$/);
              break;
            case 'stats':
              showStatsMinimal();
              toggleActiveCommand('stats', true);
              removeSlashCommand('/stats');
              break;
          }
        }
      } else if (dropdown.style.display === "block") {
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          selectedOptionIndex = (selectedOptionIndex + 1) % copyFormats.length;
          updateDropdownSelection();
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          selectedOptionIndex = (selectedOptionIndex - 1 + copyFormats.length) % copyFormats.length;
          updateDropdownSelection();
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (selectedOptionIndex >= 0) {
            handleCopy(copyFormats[selectedOptionIndex]);
            dropdown.style.display = "none";
            removeSlashCommand('/copy'); // Remove the command from the editor
          }
        }
      }
    });

    function removeSlashCommand(cmd) {
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      const range = sel.getRangeAt(0);
      let node = range.startContainer;
      let offset = range.startOffset;

      if (node.nodeType !== 3 && node.childNodes.length > 0) {
        node = node.childNodes[0];
        offset = 0;
      }

      let text = node.textContent;
      let before = text.slice(0, offset);
      let after = text.slice(offset);
      let match = before.match(/(\s*\/[a-zA-Z]+(?:\s+[^\s]+)*)\s*$/);
      if (match) {
        let start = match.index;
        let newText = before.slice(0, start) + after;
        node.textContent = newText;

        let newOffset = start;
        let newRange = document.createRange();
        newRange.setStart(node, newOffset);
        newRange.collapse(true);
        sel.removeAllRanges();
        sel.addRange(newRange);
      }
      localStorage.setItem('omi-content', editor.innerHTML);
      updateWordCount();
      updatePlaceholder();
    }

    // Save snapshot
    function saveSnapshot() {
      const content = editor.innerHTML; // Get the current content of the editor
      const now = new Date().toLocaleString(); // Get the current timestamp
      const snapshots = JSON.parse(localStorage.getItem(SNAPSHOT_KEY)) || []; // Retrieve existing snapshots or initialize an empty array
      snapshots.unshift({ name: `Snapshot - ${now}`, content }); // Add the new snapshot to the beginning of the array
      localStorage.setItem(SNAPSHOT_KEY, JSON.stringify(snapshots)); // Save the updated snapshots array to localStorage
      showToast("Snapshot saved"); // Show feedback to the user
    }

    // Export as .txt or .md
    function exportContent() {
      const text = editor.innerText;
      const html = editor.innerHTML;
      // Ask user for format
      const format = prompt('Export as .txt or .md? (type txt or md)', 'txt');
      if (!format) return;
      let blob, filename;
      if (format === 'md') {
        filename = 'omi.md';
        blob = new Blob([text], {type: 'text/markdown'});
      } else {
        filename = 'omi.txt';
        blob = new Blob([text], {type: 'text/plain'});
      }
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
      }, 100);
    }

    // Focus mode CSS (lighter, readable)
    const style = document.createElement('style');
    style.innerHTML = `body.focus-mode #word-count { display: none; } body.focus-mode { background: rgba(255,255,255,0.7) !important; color: #222 !important; }
    body.zen-mode #zen-overlay { background: rgba(255,255,255,0.7) !important; }`;
    document.head.appendChild(style);

    // Also auto-link and auto-markdown on paste and blur
    editor.addEventListener('paste', () => setTimeout(() => { autoLink(editor); autoMarkdown(editor); autoHeading(); autoMemoryLabels(editor); }, 0));
    editor.addEventListener('blur', () => { autoLink(editor); autoMarkdown(editor); autoHeading(); autoMemoryLabels(editor); });

    // Zen Mode
    function toggleZenMode() {
      const zenOverlay = document.getElementById('zen-overlay');
      const isZen = document.body.classList.toggle('zen-mode');
      zenOverlay.style.display = isZen ? 'block' : 'none';
      document.getElementById('word-count').style.display = isZen ? 'none' : '';
      timerMinimal.style.display = isZen && timerActive ? 'block' : (timerActive ? 'block' : 'none');
      statsMinimal.style.display = 'none';
      document.getElementById('active-commands').style.display = isZen ? 'none' : '';
      document.getElementById('font-switcher').style.display = isZen ? 'none' : '';
      document.getElementById('command-help-btn').style.display = isZen ? 'none' : '';
      document.getElementById('command-help-modal').style.display = 'none';
      if (isZen) {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen().catch(() => {});
        }
        editor.blur();
        setTimeout(() => editor.focus(), 100);
      } else {
        if (document.fullscreenElement) {
          document.exitFullscreen().catch(() => {});
        }
      }
    }
    // Exit Zen on Escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && document.body.classList.contains('zen-mode')) {
        toggleZenMode();
        toggleActiveCommand('zen', false);
      }
      if (e.key === 'F11') {
        e.preventDefault();
        toggleZenMode();
      }
    });

    // Timer (minimal)
    let timerInterval = null;
    let timerActive = false;
    let timerEnd = null;
    let timerMins = null;
    function startTimer(mins) {
      stopTimer();
      timerActive = true;
      timerMins = mins;
      timerEnd = Date.now() + mins * 60 * 1000;
      timerMinimal.style.display = 'block';
      updateTimerMinimal();
      timerInterval = setInterval(updateTimerMinimal, 1000);
    }
    function stopTimer() {
      timerActive = false;
      timerMins = null;
      timerEnd = null;
      clearInterval(timerInterval);
      timerMinimal.style.display = 'none';
      updateActiveCommandsDisplay();
    }
    function updateTimerMinimal() {
      if (!timerActive || !timerEnd) return;
      let ms = timerEnd - Date.now();
      if (ms <= 0) {
        timerMinimal.textContent = " 00:00";
        setTimeout(stopTimer, 2000);
        showCopyToast('Timer finished!');
        return;
      }
      let mins = Math.floor(ms / 60000);
      let secs = Math.floor((ms % 60000) / 1000);
      timerMinimal.textContent = ` ${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }

    // Minimal stats
    let sessionStart = Date.now();
    function showStatsMinimal() {
      statsMinimal.style.display = 'block';
      updateStatsMinimal();
      setTimeout(() => { statsMinimal.style.display = 'none'; toggleActiveCommand('stats', false); }, 5000);
    }
    function updateStatsMinimal() {
      if (statsMinimal.style.display !== 'block') return;
      let sessionMs = Date.now() - sessionStart;
      let sessionMin = Math.floor(sessionMs / 60000);
      let sessionSec = Math.floor((sessionMs % 60000) / 1000);
      let today = new Date().toISOString().slice(0, 10);
      let dailyKey = 'omi-daily-' + today;
      let wordCount = editor.innerText.trim() ? editor.innerText.trim().split(/\s+/).length : 0;
      let goal = parseInt(localStorage.getItem('omi-goal') || '1000', 10);
      statsMinimal.innerHTML = `Session: ${sessionMin}m ${sessionSec}s<br>Today: ${wordCount} words<br>Goal: ${goal}`;
    }
    setInterval(updateStatsMinimal, 1000);

    // Active commands logic
    function toggleActiveCommand(cmd, on = null, arg = null) {
      if (on === null) {
        // toggle
        if (activeCommands.includes(cmd)) {
          activeCommands = activeCommands.filter(c => c !== cmd);
        } else {
          activeCommands.push(cmd);
        }
      } else if (on) {
        if (!activeCommands.includes(cmd)) activeCommands.push(cmd);
      } else {
        activeCommands = activeCommands.filter(c => c !== cmd);
      }
      updateActiveCommandsDisplay();
    }
    function updateActiveCommandsDisplay() {
      if (activeCommands.length === 0) {
        activeCommandsDiv.textContent = '';
        return;
      }
      let labels = activeCommands.map(cmd => {
        if (cmd === 'zen') return 'Zen mode';
        if (cmd === 'focus') return 'Focus mode';
        if (cmd === 'typewriter') return 'Typewriter';
        if (cmd === 'lines') return 'Lines';
        if (cmd === 'timer') return timerActive && timerMins ? `Timer (${timerMins}m)` : 'Timer';
        if (cmd === 'stats') return 'Stats';
        return cmd;
      });
      activeCommandsDiv.textContent = labels.join('  •  ');
    }

    // Function to update the caret position
    function updateMacCaret() {
      if (document.activeElement !== editor) {
        editor.classList.remove('mac-caret-active');
        return;
      }
      const sel = window.getSelection();
      if (!sel.rangeCount) {
        editor.classList.remove('mac-caret-active');
        return;
      }
      const range = sel.getRangeAt(0).cloneRange();
      range.collapse(true);
      let rect = range.getClientRects()[0];
      if (!rect) {
        editor.classList.remove('mac-caret-active');
        return;
      }
      editor.classList.add('mac-caret-active');
      editor.style.setProperty('--mac-caret-x', rect.left + 'px');
      editor.style.setProperty('--mac-caret-y', rect.top + 'px');
      editor.style.setProperty('--mac-caret-height', rect.height + 'px');
    }

    // Focus the editor and show the caret on page load
    document.addEventListener('DOMContentLoaded', () => {
      editor.focus(); // Focus on the editor to show the caret
      setTimeout(() => { updateMacCaret(); resetCaretIdle(); }, 50);
    });

    // Update the caret position on input and key events
    editor.addEventListener('input', updateMacCaret);
    editor.addEventListener('keyup', updateMacCaret);
    editor.addEventListener('mouseup', updateMacCaret);
    editor.addEventListener('focus', updateMacCaret);
    editor.addEventListener('blur', () => editor.classList.remove('mac-caret-active'));

    const caretRippleEl = document.getElementById('caretRipple');
    let rippleTimer;
    function triggerCaretRipple() {
      const x = parseFloat(getComputedStyle(editor).getPropertyValue('--mac-caret-x'));
      const y = parseFloat(getComputedStyle(editor).getPropertyValue('--mac-caret-y'));
      const h = parseFloat(getComputedStyle(editor).getPropertyValue('--mac-caret-height'));
      caretRippleEl.style.left = x + 'px';
      caretRippleEl.style.top = (y + h) + 'px';
      caretRippleEl.classList.remove('ripple-animate');
      void caretRippleEl.offsetWidth;
      caretRippleEl.classList.add('ripple-animate');
    }
    function scheduleRipple() {
      clearTimeout(rippleTimer);
      caretRippleEl.classList.remove('ripple-animate');
      rippleTimer = setTimeout(triggerCaretRipple, 1000);
    }
    editor.addEventListener('input', scheduleRipple);
    editor.addEventListener('keydown', scheduleRipple);

    let idleTimer1, idleTimer2;
    function resetCaretIdle() {
      clearTimeout(idleTimer1);
      clearTimeout(idleTimer2);
      editor.classList.remove('slow-blink');
      idleTimer1 = setTimeout(() => {
        editor.classList.add('slow-blink');
        idleTimer2 = setTimeout(() => {
          triggerCaretRipple();
        }, 20000);
      }, 10000);
    }
    ['input','keydown','mousemove','mousedown'].forEach(ev => {
      editor.addEventListener(ev, resetCaretIdle);
    });

    function keepCaretCentered() {
      if (!document.body.classList.contains('typewriter-mode')) return;
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      const range = sel.getRangeAt(0).cloneRange();
      range.collapse(true);
      const rect = range.getClientRects()[0];
      if (!rect) return;
      const offset = rect.top - window.innerHeight / 2 + rect.height / 2;
      window.scrollBy(0, offset);
    }
    editor.addEventListener('input', keepCaretCentered);
    editor.addEventListener('keyup', keepCaretCentered);
    editor.addEventListener('click', keepCaretCentered);

    function clearEditorContent() {
      editor.innerHTML = ''; // Clear the editor content
      showToast("Editor content cleared."); // Show feedback
    }

    function loadSnapshots() {
      const snapshots = JSON.parse(localStorage.getItem(SNAPSHOT_KEY)) || []; // Retrieve existing snapshots

      console.log('Snapshots found:', snapshots); // Debugging line

      if (snapshots.length === 0) {
        showToast('No snapshots available'); // Show feedback if no snapshots exist
        return; // Exit if there are no snapshots
      }

      // Create dropdown
      const dropdown = document.createElement('div');
      dropdown.style.position = 'absolute';
      dropdown.style.background = '#fff'; // Match app background
      dropdown.style.borderRadius = '8px';
      dropdown.style.padding = '0.5rem';
      dropdown.style.zIndex = '1000';
      dropdown.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)'; // Slightly darker shadow for depth
      dropdown.style.maxHeight = '300px'; // Limit height for better usability
      dropdown.style.overflowY = 'auto'; // Enable scrolling if too many snapshots
      dropdown.style.width = '200px'; // Set a fixed width for consistency
      dropdown.style.fontFamily = 'inherit'; // Match app font
      dropdown.style.color = '#333'; // Darker text for readability

      dropdown.innerHTML = `<ul style="list-style: none; margin: 0; padding: 0;">${snapshots.map((snap, index) => {
        return `<li class="snapshotItem" onclick="revertToSnapshot(${index}, dropdown)">${snap.name}</li>`; // Create list items for each snapshot
      }).join('')}</ul>`;

      // Append dropdown to body
      document.body.appendChild(dropdown);
      console.log('Dropdown created and appended:', dropdown); // Debugging line

      // Position the dropdown
      const rect = getSelectionRect() || editor.getBoundingClientRect();
      dropdown.style.top = `${rect.bottom + window.scrollY}px`;
      dropdown.style.left = `${rect.left + window.scrollX}px`;
      dropdown.style.display = 'block'; // Ensure dropdown is visible

      // Close dropdown on click outside
      document.addEventListener('click', (event) => {
        if (!dropdown.contains(event.target) && event.target !== editor) {
          dropdown.remove(); // Remove dropdown if clicked outside
        }
      });
    }

    let historySnapshots = [];

    function trackHistory() {
      const currentContent = editor.innerHTML;
      historySnapshots.push(currentContent);
      if (historySnapshots.length > 20) {
        historySnapshots.shift(); // Keep only the last 20 versions
      }
    }

    // Call trackHistory() on major changes or at intervals
    setInterval(trackHistory, 5 * 60 * 1000); // Every 5 minutes

    function showHistory() {
      if (historySnapshots.length === 0) {
        showToast('No history available');
        return;
      }

      const historyDropdown = document.createElement('div');
      historyDropdown.style.position = 'absolute';
      historyDropdown.style.background = '#fff';
      historyDropdown.style.borderRadius = '8px';
      historyDropdown.style.padding = '0.5rem';
      historyDropdown.style.zIndex = '1000';
      historyDropdown.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
      historyDropdown.style.maxHeight = '300px';
      historyDropdown.style.overflowY = 'auto';
      historyDropdown.style.width = '200px';
      historyDropdown.style.fontFamily = 'inherit';
      historyDropdown.style.color = '#333';

      const items = historySnapshots.slice().reverse().map((content, i) => {
        const index = historySnapshots.length - 1 - i;
        return `<li class="snapshotItem" onclick="revertToHistory(${index}, historyDropdown)">Version ${index + 1}</li>`;
      }).join('');

      historyDropdown.innerHTML = `<ul style="list-style: none; margin: 0; padding: 0;">${items}</ul>`;

      document.body.appendChild(historyDropdown);
        const rect = getSelectionRect() || editor.getBoundingClientRect();
        historyDropdown.style.top = `${rect.bottom + window.scrollY}px`;
        historyDropdown.style.left = `${rect.left + window.scrollX}px`;
        historyDropdown.style.display = 'block';

      document.addEventListener('click', function handler(event) {
        if (!historyDropdown.contains(event.target) && event.target !== editor) {
          historyDropdown.remove();
          document.removeEventListener('click', handler);
        }
      });
    }

    function revertToHistory(index, dropdownEl) {
      const content = historySnapshots[index];
      if (content !== undefined) {
        editor.innerHTML = content;
        localStorage.setItem('omi-content', content);
        showToast(`Reverted to version ${index + 1}`);
        if (dropdownEl) dropdownEl.remove();
        removeSlashCommand('/history');
      }
    }

    const dropdown = document.getElementById("copyDropdown");
    const toast = document.getElementById("toast");

    const copyFormats = ["Plain Text", "Markdown", "HTML", "Rich Text"];
    let selectedOptionIndex = -1; // Track the selected option index

    function toggleDropdown() {
      dropdown.innerHTML = "";
      copyFormats.forEach((format, index) => {
        const div = document.createElement("div");
        div.className = "option";
        div.textContent = format;
        div.onclick = () => {
          handleCopy(format);
          dropdown.style.display = "none";
          removeSlashCommand('/copy');
        };
        dropdown.appendChild(div);
      });
      dropdown.style.display = dropdown.style.display === "block" ? "none" : "block";
      positionDropdown();
      selectedOptionIndex = -1; // Reset selection
    }

    function positionDropdown() {
      const sel = window.getSelection();
      if (sel.rangeCount > 0) {
        const range = sel.getRangeAt(0);
        const rect = range.getBoundingClientRect();
        dropdown.style.top = `${rect.bottom + window.scrollY}px`;
        dropdown.style.left = `${rect.left + window.scrollX}px`;
      }
    }

    function updateDropdownSelection() {
      const options = dropdown.getElementsByClassName("option");
      for (let i = 0; i < options.length; i++) {
        options[i].classList.remove("selected");
      }
      if (selectedOptionIndex >= 0) {
        options[selectedOptionIndex].classList.add("selected");
      }
    }

    function handleCopy(format) {
      const content = editor.innerHTML;
      let output = content;

      if (format === "Plain Text") {
        output = editor.innerText;
        navigator.clipboard.writeText(output).then(() => {
          showToast("Copied as Plain Text");
          removeSlashCommand('/copy');
        }).catch(err => {
          console.error('Failed to copy: ', err);
        });
      } else if (format === "Markdown") {
        output = toMarkdown(content);
        navigator.clipboard.writeText(output).then(() => {
          showToast("Copied as Markdown");
          removeSlashCommand('/copy');
        }).catch(err => {
          console.error('Failed to copy: ', err);
        });
      } else if (format === "HTML") {
        navigator.clipboard.writeText(content).then(() => {
          showToast("Copied as HTML");
          removeSlashCommand('/copy');
        }).catch(err => {
          console.error('Failed to copy: ', err);
        });
      } else if (format === "Rich Text") {
        const blob = new Blob([content], { type: "text/html" });
        const item = new ClipboardItem({ "text/html": blob });
        navigator.clipboard.write([item]).then(() => {
          showToast("Copied as Rich Text");
          removeSlashCommand('/copy');
        }).catch(err => {
          console.error('Failed to copy: ', err);
        });
      }
    }

    function toMarkdown(html) {
      const tmp = document.createElement('div');
      tmp.innerHTML = html;
      function walk(node) {
        let out = '';
        node.childNodes.forEach(child => {
          if (child.nodeType === 3) {
            out += child.textContent;
          } else if (child.nodeType === 1) {
            const tag = child.tagName.toLowerCase();
            if (tag === 'strong' || tag === 'b') out += '**' + walk(child) + '**';
            else if (tag === 'em' || tag === 'i') out += '*' + walk(child) + '*';
            else if (tag === 'u') out += '__' + walk(child) + '__';
            else if (tag === 'del') out += '~~' + walk(child) + '~~';
            else if (tag === 'code') out += '`' + walk(child) + '`';
            else if (tag === 'br') out += '\n';
            else if (tag === 'p') out += walk(child) + '\n\n';
            else out += walk(child);
          }
        });
        return out;
      }
      return walk(tmp).replace(/\n{3,}/g, '\n\n').trim();
    }

    function showToast(message) {
      toast.textContent = message;
      toast.style.display = "block";
      setTimeout(() => {
        toast.style.display = "none";
      }, 2000);
    }

    // Revert to selected snapshot
    function revertToSnapshot(index, dropdown) {
      const snapshot = JSON.parse(localStorage.getItem(SNAPSHOT_KEY))[index];
      if (snapshot) {
        editor.innerHTML = snapshot.content;
        localStorage.setItem('omi-content', snapshot.content); // Update the main content
        showToast(`Loaded: ${snapshot.name}`); // Show feedback to the user

        // Remove the dropdown after selection
        if (dropdown) {
          dropdown.remove(); // Close the dropdown
        }

        // Remove the '/copy' command from the editor
        removeSlashCommand('/copy'); // Remove the command from the editor
      }
    }

    function handleCopyCommand() {
      toggleDropdown();
    }

    // Clear all content and reset
    function clearAll() {
      editor.innerHTML = ''; // Clear the editor content
      localStorage.removeItem(SNAPSHOT_KEY); // Clear snapshots
      localStorage.removeItem('omi-content'); // Clear main content
      showToast("All content cleared and reset."); // Show feedback
    }

    // Add an event listener to the editor for slash commands
    editor.addEventListener('input', () => {
      showSlashSuggestionsForCurrent();
    });
    function showSlashSuggestionsForCurrent() {
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      const range = sel.getRangeAt(0).cloneRange();
      const pre = range.cloneRange();
      pre.selectNodeContents(editor);
      pre.setEnd(range.endContainer, range.endOffset);
      const text = pre.toString();
      const lastSlashIndex = text.lastIndexOf('/');
      if (lastSlashIndex !== -1 && (lastSlashIndex === 0 || /\s/.test(text[lastSlashIndex-1]))) {
        const commandInput = text.slice(lastSlashIndex);
        showCommandSuggestions(commandInput);
      } else {
        hideSlashSuggestions();
      }
    }

    // Function to show command suggestions
    function showCommandSuggestions(input) {
        const suggestions = ["clear","clearx","save","load","history","copy","export","image","pdf","zen","focus","timer","stats","typewriter","lines","font","blog","newsletter","ebook"];
        const filteredSuggestions = suggestions.filter(cmd => cmd.startsWith(input.slice(1)));

        slashSuggestions.innerHTML = filteredSuggestions.map(cmd => `<li data-cmd="${cmd}">${cmd}</li>`).join("");
        if (filteredSuggestions.length > 0) {
          const rect = getSelectionRect() || editor.getBoundingClientRect();
          slashSuggestions.style.left = `${rect.left}px`;
          slashSuggestions.style.top = `${rect.bottom + 5}px`;
          slashSuggestions.style.display = 'block';
        } else {
          slashSuggestions.style.display = 'none';
        }
    }
    function hideSlashSuggestions() {
      slashSuggestions.style.display = "none";
    }
    slashSuggestions.addEventListener("mousedown", (e) => {
      const li = e.target.closest("li");
      if (!li) return;
      e.preventDefault();
      insertSlashCommand(li.dataset.cmd);
    });
    function insertSlashCommand(cmd) {
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      const range = sel.getRangeAt(0);
      const node = range.startContainer;
      if (node.nodeType === 3) {
        const text = node.textContent;
        const lastSlash = text.lastIndexOf("/");
        if (lastSlash !== -1) {
          node.textContent = text.slice(0, lastSlash + 1) + cmd;
          const newPos = lastSlash + 1 + cmd.length;
          range.setStart(node, newPos);
          range.collapse(true);
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }
      hideSlashSuggestions();
    }
    editor.addEventListener("keydown", (e) => {
      if (e.key === "Tab" && slashSuggestions.style.display === "block") {
        e.preventDefault();
        const first = slashSuggestions.querySelector("li");
        if (first) insertSlashCommand(first.dataset.cmd);
      }
    });

    // Function to execute the command
    function executeCommand(cmd) {
      console.log('Executing command:', cmd);
      if (cmd === 'image') {
        openImageSelector();
      } else if (cmd === 'pdf') {
        openPdfSelector();
      } else if (cmd === 'clear') {
        clearEditorContent();
      } else if (cmd === 'save') {
        saveSnapshot();
      } else if (cmd === 'load') {
        loadSnapshots();
      } else if (cmd === 'history') {
        showHistory();
      } else if (cmd === 'copy') {
        handleCopyCommand();
      } else if (cmd === 'zen') {
        toggleZenMode();
        toggleActiveCommand('zen');
      } else if (cmd === 'focus') {
        document.body.classList.toggle('focus-mode');
        toggleActiveCommand('focus');
      } else if (cmd === 'timer') {
        const mins = parseInt(prompt('Minutes', '25'), 10);
        if (!isNaN(mins) && mins > 0) {
          startTimer(mins);
          toggleActiveCommand('timer', true, mins);
        }
      } else if (cmd === 'stats') {
        showStatsMinimal();
        toggleActiveCommand('stats', true);
      } else if (cmd === 'typewriter') {
        document.body.classList.toggle('typewriter-mode');
        toggleActiveCommand('typewriter');
      } else if (cmd === 'lines') {
        document.body.classList.toggle('line-highlight');
        toggleActiveCommand('lines');
      } else if (cmd === 'font') {
        const font = fonts[Math.floor(Math.random() * fonts.length)];
        setFont(font);
      } else if (cmd === 'blog') {
        setLayout('blog');
      } else if (cmd === 'newsletter') {
        setLayout('newsletter');
      } else if (cmd === 'ebook') {
        setLayout('ebook');
      }
      hideSlashSuggestions();
    }

    // Function to open the file explorer for image selection
  function openImageSelector() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.onchange = (event) => {
        const file = event.target.files[0];
        if (file) insertImageFile(file);
      };
      input.click();
    }

    function insertImageFile(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const figure = document.createElement('figure');
        figure.className = 'image-block resizable';
        const img = document.createElement('img');
        img.className = 'resizable';
        img.src = e.target.result;
        img.alt = 'Image';
        figure.appendChild(img);
        editor.appendChild(figure);
        const p = document.createElement('p');
        p.innerHTML = '<br>';
        figure.after(p);
        const range = document.createRange();
        range.setStart(p, 0);
        range.collapse(true);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
        makeImageResizable(img);
        localStorage.setItem('omi-content', editor.innerHTML);
      };
      reader.readAsDataURL(file);
    }

    function openPdfSelector() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'application/pdf';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (file) insertPdfFile(file);
      };
      input.click();
    }

    function insertPdfFile(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const div = document.createElement('div');
        div.className = 'pdf-block resizable';
        const embed = document.createElement('embed');
        embed.className = 'resizable';
        embed.src = e.target.result;
        embed.type = 'application/pdf';
        div.appendChild(embed);
        editor.appendChild(div);
        const p = document.createElement('p');
        p.innerHTML = '<br>';
        div.after(p);
        const range = document.createRange();
        range.setStart(p, 0);
        range.collapse(true);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
        makeImageResizable(embed);
        localStorage.setItem('omi-content', editor.innerHTML);
      };
      reader.readAsDataURL(file);
    }

    function makeImageResizable(el) {
      const parent = el.parentElement;
      parent.style.position = 'relative';
      // remove old handles if any
      parent.querySelectorAll('.resize-handle').forEach(h => h.remove());
      const dirs = ['nw','ne','sw','se'];
      dirs.forEach(dir => {
        const handle = document.createElement('span');
        handle.className = 'resize-handle';
        handle.dataset.dir = dir;
        parent.appendChild(handle);
        handle.addEventListener('mousedown', (e) => {
          e.preventDefault();
          let startX = e.clientX;
          let startY = e.clientY;
          let startW = el.offsetWidth;
          let startH = el.offsetHeight;
          function onMove(ev) {
            let dx = ev.clientX - startX;
            let dy = ev.clientY - startY;
            let newW = startW;
            let newH = startH;
            if (dir.includes('e')) newW += dx;
            if (dir.includes('w')) newW -= dx;
            if (dir.includes('s')) newH += dy;
            if (dir.includes('n')) newH -= dy;
            if (newW > 20) {
              el.style.width = newW + 'px';
              parent.style.width = newW + 'px';
            }
            if (newH > 20) {
              el.style.height = newH + 'px';
              parent.style.height = newH + 'px';
            }
          }
          function onUp() {
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
            localStorage.setItem('omi-content', editor.innerHTML);
          }
          document.addEventListener('mousemove', onMove);
          document.addEventListener('mouseup', onUp);
        });
      });
    }

    const commandDescriptions = {
      "Ctrl+M": "Change theme" ,
      clear: 'Clear editor',
      clearx: 'Reset everything',
      save: 'Save snapshot',
      load: 'Load snapshot',
      history: 'Show history',
      copy: 'Copy content',
      export: 'Export text',
      image: 'Insert image',
      pdf: 'Insert PDF',
      zen: 'Toggle zen mode',
      focus: 'Toggle focus mode',
      timer: 'Start a timer',
      stats: 'Show stats',
      typewriter: 'Typewriter mode',
      F11: 'Zen mode',
      lines: 'Highlight lines',
      font: 'Random font',
      blog: 'Blog layout',
      newsletter: 'Newsletter layout',
      ebook: 'eBook layout'
    };

    const helpBtn = document.getElementById('command-help-btn');
    const helpModal = document.getElementById('command-help-modal');
    helpBtn.addEventListener('click', () => {
      if (helpModal.style.display === 'block') {
        helpModal.style.display = 'none';
        return;
      }
      let html = '<h3 style="margin-top:0">Commands</h3><ul style="margin:0;padding-left:1em;">';
      for (const cmd in commandDescriptions) {
        const label = cmd.startsWith("Ctrl") ? cmd : "/" + cmd;
        html += `<li><b>${label}</b> - ${commandDescriptions[cmd]}</li>`;
      }
      html += '</ul>';
      helpModal.innerHTML = html;
      helpModal.style.display = 'block';
    });

    const highlightPicker = document.getElementById('highlight-picker');
    const highlightColors = ['#fff59d', '#a5d6a7', '#90caf9', '#f48fb1'];
    highlightColors.forEach(c => {
      const span = document.createElement('span');
      span.style.backgroundColor = c;
      highlightPicker.appendChild(span);
      span.addEventListener('mousedown', (e) => {
        e.preventDefault();
        document.execCommand('styleWithCSS', false, true);
        document.execCommand('hiliteColor', false, c);
        highlightPicker.style.display = 'none';
        localStorage.setItem('omi-content', editor.innerHTML);
      });
    });

    function showHighlightPicker() {
      const sel = window.getSelection();
      if (sel.rangeCount && !sel.isCollapsed && editor.contains(sel.anchorNode)) {
        const rect = getSelectionRect();
        if (rect) {
          highlightPicker.style.left = rect.left + 'px';
          highlightPicker.style.top = (rect.top - 30 + window.scrollY) + 'px';
          highlightPicker.style.display = 'flex';
        }
      } else {
        highlightPicker.style.display = 'none';
      }
    }

    editor.addEventListener('mouseup', () => setTimeout(showHighlightPicker, 0));
    editor.addEventListener('keyup', (e) => {
      if (e.key.startsWith('Arrow') || e.key === 'Shift') {
        showHighlightPicker();
      }
    });
    document.addEventListener('mousedown', (e) => {
      if (!highlightPicker.contains(e.target)) {
        highlightPicker.style.display = 'none';
      }
    });
  </script>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      updateMacCaret();
    });
    window.onload = function() {
       document.getElementById('editor').focus();
   };
  </script>

  <script>window.SOLA_SITE_ID = "12u";</script>
  <script src="https://sola-three.vercel.app/api/sola.js" defer></script>

</body>
</html>

