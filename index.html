<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Omi</title>
  <!-- Use Geist font -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Geist:wght@400;700&display=swap">
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: var(--bg, #f7f7f8);
      color: var(--fg, #222);
      font-family: 'Geist', 'Inter', sans-serif;
      width: 100vw;
      height: 100vh;
      transition: background 0.2s, color 0.2s;
    }
    body {
      min-height: 100vh;
      min-width: 100vw;
      overflow: hidden;
    }
    #editor {
      outline: none;
      border: none;
      width: 100vw;
      height: 100vh;
      padding: 5vh 10vw;
      box-sizing: border-box;
      font-size: 1.25rem;
      background: transparent;
      line-height: 1.7;
      resize: none;
      color: inherit;
      font-family: inherit;
      transition: background 0.2s, color 0.2s;
      caret-color: transparent;
      position: relative;
    }
    #editor.mac-caret-active::after {
      content: '';
      display: block;
      position: fixed;
      width: 3px;
      height: var(--mac-caret-height, 1.25em);
      border-radius: 1.5px;
      background: var(--mac-caret-color, #222);
      z-index: 10010;
      pointer-events: none;
      left: var(--mac-caret-x, -1000px);
      top: var(--mac-caret-y, -1000px);
      animation: mac-caret-blink 1.1s cubic-bezier(.4,0,.2,1) infinite;
      opacity: 1;
      will-change: opacity, left, top, height;
    }
    @keyframes mac-caret-blink {
      0% { opacity: 1; }
      60% { opacity: 1; }
      70% { opacity: 0; }
      100% { opacity: 0; }
    }
    body[data-theme="dark"] #editor.mac-caret-active::after,
    body[data-theme="night"] #editor.mac-caret-active::after {
      background: #fff;
    }
    /* Make links more visible in dark and night mode */
    body[data-theme="dark"] a,
    body[data-theme="night"] a {
      color: #7ecbff;
      text-decoration-color: #7ecbff;
    }
    #commandBar {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.96);
      background: rgba(255, 255, 255, 0.93);
      backdrop-filter: blur(22px) saturate(1.2);
      box-shadow: 0 8px 32px 0 rgba(0,0,0,0.18), 0 0 32px 0 #aaf4, 0 0 0 2px #fff4;
      border-radius: 16px;
      padding: 1.4rem 1.3rem 1.1rem 1.3rem;
      width: 350px;
      opacity: 0;
      transition: opacity 0.32s cubic-bezier(.4,0,.2,1), transform 0.32s cubic-bezier(.4,0,.2,1), box-shadow 0.32s cubic-bezier(.4,0,.2,1);
      z-index: 9999;
      display: block;
      pointer-events: auto;
      box-sizing: border-box;
      filter: drop-shadow(0 2px 24px #aaf3) drop-shadow(0 0 32px #fff3);
      will-change: opacity, transform, box-shadow;
    }
    #commandBar.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
      pointer-events: auto;
      box-shadow: 0 12px 48px 0 rgba(0,0,0,0.22), 0 0 48px 0 #aaf6, 0 0 0 2px #fff6;
    }
    #commandBar.hidden {
      display: none;
    }
    .command-bar-input-wrap {
      position: relative;
      margin-bottom: 0.7em;
    }
    #commandBarInput {
      width: 100%;
      font-size: 1.1em;
      padding: 0.5em 0.7em;
      border-radius: 7px;
      border: none;
      background: rgba(255,255,255,0.7);
      box-shadow: 0 1px 4px #0001;
      outline: none;
      font-family: inherit;
      color: #222;
      letter-spacing: 0.01em;
    }
    body[data-theme="dark"] #commandBar, body[data-theme="night"] #commandBar {
      background: rgba(24,24,27,0.98);
      box-shadow: 0 8px 32px rgba(0,0,0,0.28), 0 0 0 2px #2228;
    }
    body[data-theme="dark"] #commandBarInput, body[data-theme="night"] #commandBarInput {
      background: rgba(32,32,40,0.85);
      color: #f7f7f8;
    }
    .type-caret {
      position: absolute;
      right: 1.1em;
      top: 50%;
      width: 2px;
      height: 1.2em;
      background: #222;
      border-radius: 1px;
      transform: translateY(-50%);
      animation: type-caret-fade 1.1s cubic-bezier(.4,0,.2,1) infinite;
      pointer-events: none;
      opacity: 1;
      will-change: opacity;
    }
    @keyframes type-caret-fade {
      0% { opacity: 1; }
      60% { opacity: 1; }
      70% { opacity: 0; }
      100% { opacity: 0; }
    }
    body[data-theme="dark"] .type-caret, body[data-theme="night"] .type-caret {
      background: #fff;
    }
    #commandBarList {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    #commandBarList li {
      opacity: 0;
      transform: translateY(24px) scale(0.98);
      transition: opacity 0.32s cubic-bezier(.4,0,.2,1), transform 0.32s cubic-bezier(.4,0,.2,1);
      font-size: 1.08em;
      color: #555;
      padding: 0.22em 0.3em;
      border-radius: 6px;
      margin-bottom: 0.13em;
      background: none;
      cursor: pointer;
      will-change: opacity, transform;
    }
    #commandBar.show #commandBarList li {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
    #commandBar.show #commandBarList li:nth-child(1) { transition-delay: 0.08s; }
    #commandBar.show #commandBarList li:nth-child(2) { transition-delay: 0.16s; }
    #commandBar.show #commandBarList li:nth-child(3) { transition-delay: 0.24s; }
    #commandBar.show #commandBarList li:nth-child(4) { transition-delay: 0.32s; }
    #commandBar.show #commandBarList li:nth-child(5) { transition-delay: 0.40s; }
    #commandBar.show #commandBarList li:nth-child(6) { transition-delay: 0.48s; }
    #commandBarList li:hover, #commandBarList li:focus {
      background: #f0f0f3;
      color: #222;
    }
    body[data-theme="dark"] #commandBarList li:hover, body[data-theme="night"] #commandBarList li:hover {
      background: #232329;
      color: #fff;
    }
    /* Theme variables */
    :root {
      --bg: #f7f7f8;
      --fg: #222;
      --menu-bg: #fff;
    }
    body[data-theme="dark"] {
      --bg: #18181b;
      --fg: #f7f7f8;
      --menu-bg: #232329;
    }
    body[data-theme="night"] {
      --bg: #101014;
      --fg: #c3c3e5;
      --menu-bg: #18181b;
    }
    body[data-theme="dark"] #command-menu button:hover,
    body[data-theme="night"] #command-menu button:hover {
      background: #232329;
    }
    input[type="checkbox"] {
      transform: scale(1.2);
      margin-right: 0.5em;
      vertical-align: middle;
    }
    #editor.empty:before {
      content: attr(data-placeholder);
      color: #aaa;
      pointer-events: none;
      position: absolute;
      left: 10vw;
      top: 5vh;
      font-size: 1.25rem;
      font-family: inherit;
      opacity: 0.6;
    }
    #word-count {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 1.5vh;
      text-align: center;
      color: #aaa;
      font-size: 0.95rem;
      font-family: inherit;
      pointer-events: none;
      user-select: none;
      letter-spacing: 0.01em;
    }
    a {
      text-decoration: underline;
      text-decoration-color: #b3b3b3;
      text-underline-offset: 2px;
      /* Remove red underline from spellcheck */
      -webkit-text-decoration-skip: none;
      text-decoration-skip-ink: none;
      /* Remove red squiggle in some browsers */
      spellcheck: false;
    }
    a[spellcheck="false"] {
      /* Remove red underline for links */
      text-decoration: underline;
      text-decoration-color: #b3b3b3;
      text-underline-offset: 2px;
      -webkit-text-decoration-skip: none;
      text-decoration-skip-ink: none;
    }
    #copyDropdown {
      position: absolute;
      background: var(--menu-bg, white);
      border-radius: 8px;
      padding: 0.5rem 0;
      display: none;
      z-index: 1000;
      min-width: 200px;
      box-shadow: none;
      margin-top: 5px;
    }
    .option {
      padding: 0.5rem 1rem;
      cursor: pointer;
    }
    .option:hover {
      background: #f0f0f0;
    }
    .option.selected {
      background: #e0e0e0; /* Highlight selected option */
    }
    #toast {
      position: fixed;
      bottom: 1.5vh;
      left: 1vw;
      color: #aaa;
      font-size: 0.9rem;
      display: none;
      z-index: 9999;
    }
    .snapshotItem {
      padding: 0.5rem 1rem; /* Add padding for better click area */
      transition: background 0.2s; /* Smooth background transition */
    }
    .snapshotItem:hover {
      background: #f0f0f0; /* Light background on hover */
    }
    .snapshotItem:focus {
      outline: none; /* Remove default outline */
      background: #e0e0e0; /* Highlight on focus */
    }
  </style>
</head>
<body>
  <div id="editor" contenteditable="true" spellcheck="true" aria-label="Omi" data-placeholder="Start writing..."></div>
  <div id="commandBar" class="hidden">
    <div class="command-bar-input-wrap">
      <input id="commandBarInput" type="text" placeholder="Type a command..." autocomplete="off" />
      <span class="type-caret"></span>
    </div>
    <ul id="commandBarList">
      <li onclick="clearEditor()">Clear</li>
      <li onclick="saveSnapshot()">Save</li>
      <li onclick="loadSnapshots()">Load</li>
      <li onclick="showHistory()">History</li>
      <li onclick="copyContent()">Copy</li>
    </ul>
  </div>
  <div id="word-count"></div>
  <div id="timer-minimal" style="position:fixed;right:1vw;bottom:1.5vh;text-align:right;color:#aaa;font-size:0.95rem;font-family:inherit;pointer-events:none;user-select:none;letter-spacing:0.01em;z-index:10001;display:none;"></div>
  <div id="active-commands" style="position:fixed;left:1vw;bottom:1.5vh;z-index:10002;color:#aaa;font-size:0.95rem;font-family:inherit;user-select:none;pointer-events:none;text-align:left;"></div>
  <div id="stats-minimal" style="position:fixed;left:1vw;bottom:4.5vh;z-index:10003;color:#aaa;font-size:0.95rem;font-family:inherit;user-select:none;pointer-events:none;text-align:left;display:none;"></div>
  <div id="zen-overlay" style="display:none;position:fixed;z-index:99999;top:0;left:0;width:100vw;height:100vh;background:rgba(255,255,255,0.7);backdrop-filter:blur(2.5px);"></div>
  <div id="timer-box" style="display:none;position:fixed;top:2vh;right:2vw;z-index:10000;background:rgba(30,30,40,0.92);color:#fff;padding:0.7em 1.3em;border-radius:8px;font-size:1.2rem;font-family:inherit;box-shadow:0 2px 12px rgba(0,0,0,0.12);"></div>
  <div id="stats-modal" style="display:none;position:fixed;z-index:10001;top:50%;left:50%;transform:translate(-50%,-50%);background:#fff;color:#222;padding:2em 2.5em;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,0.18);font-family:inherit;min-width:260px;max-width:90vw;"></div>
  <div id="link-tooltip" style="display:none;position:fixed;z-index:99999;"></div>
  <div id="copyDropdown"></div>
  <div id="toast"></div>
  <script>
    const SNAPSHOT_KEY = "omi-snapshots"; // Define the key for storing snapshots
    const editor = document.getElementById('editor');
    const menu = document.getElementById('command-menu');
    let selectionRange = null;
    let themeCycle = ['light', 'dark', 'night'];

    // Load from localStorage
    editor.innerHTML = localStorage.getItem('omi-content') || '';
    const savedTheme = localStorage.getItem('omi-theme') || 'light';
    document.body.setAttribute('data-theme', savedTheme);

    // Auto-save to localStorage
    editor.addEventListener('input', () => {
      localStorage.setItem('omi-content', editor.innerHTML);
    });

    // Save theme
    function setTheme(theme) {
      document.body.setAttribute('data-theme', theme);
      localStorage.setItem('omi-theme', theme);
    }

    // Helper: get selection rect
    function getSelectionRect() {
      const sel = window.getSelection();
      if (sel.rangeCount === 0) return null;
      const range = sel.getRangeAt(0).cloneRange();
      if (range.collapsed) return null;
      const rect = range.getBoundingClientRect();
      return rect;
    }

    // Command Bar JS
    const commandBar = document.getElementById('commandBar');
    const commandBarInput = document.getElementById('commandBarInput');
    const commandBarList = document.getElementById('commandBarList');
    let commandBarOpen = false;
    function openCommandBar() {
      if (commandBarOpen) return;
      commandBar.classList.remove('hidden');
      setTimeout(() => commandBar.classList.add('show'), 10);
      commandBarInput.value = '';
      commandBarInput.focus();
      commandBarOpen = true;
      // Animate list items
      Array.from(commandBarList.children).forEach((li, i) => {
        li.style.opacity = '0';
        li.style.transform = 'translateY(32px) scale(0.98)';
        setTimeout(() => {
          li.style.opacity = '1';
          li.style.transform = 'translateY(0) scale(1)';
        }, 120 + i * 80);
      });
      // Select first item visually (future: add .selected class)
      if (commandBarList.children.length > 0) {
        commandBarList.children[0].classList.add('selected');
      }
    }
    function closeCommandBar() {
      if (!commandBarOpen) return;
      commandBar.classList.remove('show');
      setTimeout(() => commandBar.classList.add('hidden'), 320);
      commandBarOpen = false;
      // Remove selection
      Array.from(commandBarList.children).forEach(li => li.classList.remove('selected'));
      editor.focus();
    }
    document.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        if (!commandBarOpen) openCommandBar();
      } else if (e.key === 'Escape' && commandBarOpen) {
        closeCommandBar();
      }
    });
    // Close on click outside
    document.addEventListener('mousedown', (e) => {
      if (commandBarOpen && !commandBar.contains(e.target)) closeCommandBar();
    });
    // Enter closes bar
    commandBarInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') closeCommandBar();
    });

    // Replace [] with checkbox when typed
    editor.addEventListener('input', (e) => {
      // Only run if last 2 chars are []
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      const range = sel.getRangeAt(0);
      const node = range.startContainer;
      if (node.nodeType === 3) { // text node
        let text = node.textContent;
        if (text && text.endsWith('[]')) {
          // Replace [] with checkbox
          const newText = text.slice(0, -2);
          node.textContent = newText;
          // Insert checkbox
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          range.setStart(node, newText.length);
          range.collapse(true);
          range.insertNode(checkbox);
          // Move caret after checkbox
          const space = document.createTextNode(' ');
          checkbox.after(space);
          range.setStartAfter(space);
          range.collapse(true);
          sel.removeAllRanges();
          sel.addRange(range);
          // Save to localStorage
          localStorage.setItem('omi-content', editor.innerHTML);
        }
      }
      // Auto-link URLs as you type
      autoLink(editor);
      // Inline Markdown as you type
      autoMarkdown(editor);
      // Placeholder
      updatePlaceholder();
    });

    // Auto-link URLs in the editor
    function autoLink(container) {
      const urlRegex = /(https?:\/\/[\w\-._~:/?#[\]@!$&'()*+,;=%]+)/g;
      function processNode(node) {
        if (node.nodeType === 3) { // text node
          let text = node.textContent;
          if (urlRegex.test(text)) {
            const frag = document.createDocumentFragment();
            let lastIndex = 0;
            text.replace(urlRegex, (url, match, offset) => {
              if (offset > lastIndex) {
                frag.appendChild(document.createTextNode(text.slice(lastIndex, offset)));
              }
              const a = document.createElement('a');
              a.href = url;
              a.textContent = url;
              a.target = '_blank';
              a.setAttribute('spellcheck', 'false');
              frag.appendChild(a);
              lastIndex = offset + url.length;
            });
            if (lastIndex < text.length) {
              frag.appendChild(document.createTextNode(text.slice(lastIndex)));
            }
            node.replaceWith(frag);
          }
        } else if (node.nodeType === 1 && node.childNodes && node.tagName !== 'A') {
          // Don't process inside links
          for (let i = node.childNodes.length - 1; i >= 0; i--) {
            processNode(node.childNodes[i]);
          }
        }
      }
      processNode(container);
      // Set spellcheck=false on all links (in case of pasted HTML)
      container.querySelectorAll('a').forEach(a => a.setAttribute('spellcheck', 'false'));
    }

    // Inline Markdown support: **bold** and *italic*
    function autoMarkdown(container) {
      function processNode(node) {
        if (node.nodeType === 3) { // text node
          let text = node.textContent;
          // Bold: **text**
          let changed = false;
          text = text.replace(/\*\*([^*]+)\*\*/g, (m, p1) => {
            changed = true;
            return `\u0000b\u0000${p1}\u0000/b\u0000`;
          });
          // Italic: *text*
          text = text.replace(/\*([^*]+)\*/g, (m, p1) => {
            changed = true;
            return `\u0000i\u0000${p1}\u0000/i\u0000`;
          });
          if (changed) {
            // Replace with HTML nodes
            let frag = document.createDocumentFragment();
            let parts = text.split(/(\u0000[bi]\u0000|\u0000\/[bi]\u0000)/);
            let stack = [];
            for (let part of parts) {
              if (part === '\u0000b\u0000') {
                let b = document.createElement('b');
                stack.push(b);
              } else if (part === '\u0000i\u0000') {
                let i = document.createElement('i');
                stack.push(i);
              } else if (part === '\u0000/b\u0000' || part === '\u0000/i\u0000') {
                let el = stack.pop();
                if (stack.length > 0) {
                  stack[stack.length - 1].appendChild(el);
                } else {
                  frag.appendChild(el);
                }
              } else if (part) {
                if (stack.length > 0) {
                  stack[stack.length - 1].appendChild(document.createTextNode(part));
                } else {
                  frag.appendChild(document.createTextNode(part));
                }
              }
            }
            node.replaceWith(frag);
          }
        } else if (node.nodeType === 1 && node.childNodes && node.tagName !== 'B' && node.tagName !== 'I' && node.tagName !== 'CODE') {
          for (let i = node.childNodes.length - 1; i >= 0; i--) {
            processNode(node.childNodes[i]);
          }
        }
      }
      processNode(container);
    }

    // Placeholder logic
    function updatePlaceholder() {
      if (editor.innerText.trim() === '') {
        editor.classList.add('empty');
      } else {
        editor.classList.remove('empty');
      }
    }
    updatePlaceholder();
    editor.addEventListener('focus', updatePlaceholder);
    editor.addEventListener('blur', updatePlaceholder);

    // Copy helper
    function copyContent() {
      const content = editor.innerHTML; // Get the current content of the editor
      const format = 'Plain Text'; // You can modify this to allow format selection if needed

      if (format === "Plain Text") {
        const output = editor.innerText;
        navigator.clipboard.writeText(output).then(() => {
          showToast("Copied as Plain Text");
          removeSlashCommand('/copy'); // Remove the command from the editor
        }).catch(err => {
          console.error('Failed to copy: ', err);
        });
      } else if (format === "Markdown") {
        const output = toMarkdown(content);
        navigator.clipboard.writeText(output).then(() => {
          showToast("Copied as Markdown");
          removeSlashCommand('/copy'); // Remove the command from the editor
        }).catch(err => {
          console.error('Failed to copy: ', err);
        });
      } else if (format === "HTML") {
        navigator.clipboard.writeText(content).then(() => {
          showToast("Copied as HTML");
          removeSlashCommand('/copy'); // Remove the command from the editor
        }).catch(err => {
          console.error('Failed to copy: ', err);
        });
      } else if (format === "Rich Text") {
        const blob = new Blob([content], { type: "text/html" });
        const item = new ClipboardItem({ "text/html": blob });
        navigator.clipboard.write([item]).then(() => {
          showToast("Copied as Rich Text");
          removeSlashCommand('/copy'); // Remove the command from the editor
        }).catch(err => {
          console.error('Failed to copy: ', err);
        });
      }
    }

    // CMD/CTRL+M for theme mode
    editor.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key.toLowerCase() === 'm') {
        e.preventDefault();
        let current = document.body.getAttribute('data-theme') || 'light';
        let idx = themeCycle.indexOf(current);
        let next = themeCycle[(idx + 1) % themeCycle.length];
        setTheme(next);
      }
    });

    // Double-click link to open in new tab
    editor.addEventListener('dblclick', (e) => {
      if (e.target.tagName === 'A') {
        window.open(e.target.href, '_blank');
      }
    });

    // Link hover tooltip with title and favicon
    const tooltip = document.getElementById('link-tooltip');
    let tooltipTimeout;
    editor.addEventListener('mouseover', async (e) => {
      if (e.target.tagName === 'A') {
        const link = e.target;
        tooltip.style.display = 'block';
        tooltip.style.left = (e.clientX + 12) + 'px';
        tooltip.style.top = (e.clientY + 12) + 'px';
        tooltip.innerHTML = 'Loading...';
        // Fetch title and favicon
        try {
          const url = new URL(link.href);
          const favicon = url.origin + '/favicon.ico';
          let title = link.href;
          // Try to fetch title (CORS may block)
          let gotTitle = false;
          try {
            const resp = await fetch('https://corsproxy.io/?' + encodeURIComponent(link.href));
            const text = await resp.text();
            const match = text.match(/<title>(.*?)<\/title>/i);
            if (match) {
              title = match[1];
              gotTitle = true;
            }
          } catch {}
          tooltip.innerHTML = `<img src="${favicon}" style="width:18px;height:18px;vertical-align:middle;margin-right:6px;"> <span>${title}</span>`;
        } catch {
          tooltip.innerHTML = link.href;
        }
      }
    });
    editor.addEventListener('mousemove', (e) => {
      if (e.target.tagName === 'A') {
        tooltip.style.left = (e.clientX + 12) + 'px';
        tooltip.style.top = (e.clientY + 12) + 'px';
      }
    });
    editor.addEventListener('mouseout', (e) => {
      if (e.target.tagName === 'A') {
        tooltip.style.display = 'none';
        tooltip.innerHTML = '';
      }
    });

    // Word and letter count
    const wordCountDiv = document.getElementById('word-count');
    const timerMinimal = document.getElementById('timer-minimal');
    const activeCommandsDiv = document.getElementById('active-commands');
    const statsMinimal = document.getElementById('stats-minimal');
    let activeCommands = [];
    function updateWordCount() {
      let text = editor.innerText.trim();
      let wordCount = text ? text.split(/\s+/).length : 0;
      let letterCount = text.replace(/\s+/g, '').length;
      wordCountDiv.textContent = `${wordCount === 1 ? '1 word' : wordCount + ' words'} • ${letterCount} letters`;
      // Save daily word count
      let today = new Date().toISOString().slice(0, 10);
      let dailyKey = 'omi-daily-' + today;
      localStorage.setItem(dailyKey, String(wordCount));
      updateStatsMinimal();
    }
    editor.addEventListener('input', updateWordCount);
    updateWordCount();

    // Slash commands
    editor.addEventListener('keydown', async (e) => {
      if (e.key === 'Enter') {
        const text = editor.innerText.trim();
        
        if (text.endsWith('/clear')) {
          e.preventDefault(); // Prevent the default action
          clearEditorContent(); // Call the function to clear the editor content
          removeSlashCommand('/clear'); // Remove the command from the editor
        } else if (text.endsWith('/clearx')) {
          e.preventDefault(); // Prevent the default action
          clearAll(); // Call the function to clear all content and reset
          removeSlashCommand('/clearx'); // Remove the command from the editor
        } else if (text.endsWith('/copy')) {
          e.preventDefault();
          handleCopyCommand(); // Call the function to copy content
          removeSlashCommand('/copy'); // Remove the command from the editor
        } else if (text.endsWith('/load')) {
          e.preventDefault();
          loadSnapshots(); // Call the function to load snapshots
          removeSlashCommand('/load'); // Remove the command from the editor
        } else if (text.endsWith('/save')) {
          e.preventDefault();
          saveSnapshot(); // Call the function to save a snapshot
          removeSlashCommand('/save'); // Remove the command from the editor
        } else if (text.endsWith('/export')) {
          e.preventDefault();
          exportContent(); // Call the function to export content
          removeSlashCommand('/export'); // Remove the command from the editor
        } else if (text.endsWith('/focus')) {
          e.preventDefault();
          document.body.classList.toggle('focus-mode');
          toggleActiveCommand('focus');
          removeSlashCommand('/focus'); // Remove the command from the editor
        } else if (/\/zen$/.test(text)) {
          e.preventDefault();
          toggleZenMode();
          toggleActiveCommand('zen');
          removeSlashCommand('/zen'); // Remove the command from the editor
        } else if (/\/timer(\s+\d+|\s+stop|\s+0)?$/.test(text)) {
          e.preventDefault();
          const match = text.match(/\/timer(?:\s+(\d+|stop|0))?$/);
          if (match) {
            if (match[1] === 'stop' || match[1] === '0') {
              stopTimer();
              toggleActiveCommand('timer', false);
            } else {
              let mins = parseInt(match[1] || '25', 10);
              if (!isNaN(mins) && mins > 0) startTimer(mins);
              toggleActiveCommand('timer', true, mins);
            }
          }
          removeSlashCommand(/\/timer(\s+\d+|\s+stop|\s+0)?$/); // Remove the command from the editor
        } else if (/\/stats$/.test(text)) {
          e.preventDefault();
          showStatsMinimal();
          toggleActiveCommand('stats', true);
          removeSlashCommand('/stats'); // Remove the command from the editor
        }
      } else if (dropdown.style.display === "block") {
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          selectedOptionIndex = (selectedOptionIndex + 1) % copyFormats.length;
          updateDropdownSelection();
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          selectedOptionIndex = (selectedOptionIndex - 1 + copyFormats.length) % copyFormats.length;
          updateDropdownSelection();
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (selectedOptionIndex >= 0) {
            handleCopy(copyFormats[selectedOptionIndex]);
            dropdown.style.display = "none";
            removeSlashCommand('/copy'); // Remove the command from the editor
          }
        }
      }
    });

    function removeSlashCommand(cmd) {
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      const range = sel.getRangeAt(0);
      let node = range.startContainer;
      let offset = range.startOffset;

      if (node.nodeType !== 3 && node.childNodes.length > 0) {
        node = node.childNodes[0];
        offset = 0;
      }

      let text = node.textContent;
      let before = text.slice(0, offset);
      let after = text.slice(offset);
      let match = before.match(/(\s*\/[a-zA-Z]+(?:\s+[^\s]+)*)\s*$/);
      if (match) {
        let start = match.index;
        let newText = before.slice(0, start) + after;
        node.textContent = newText;

        let newOffset = start;
        let newRange = document.createRange();
        newRange.setStart(node, newOffset);
        newRange.collapse(true);
        sel.removeAllRanges();
        sel.addRange(newRange);
      }
      localStorage.setItem('omi-content', editor.innerHTML);
      updateWordCount();
      updatePlaceholder();
    }

    // Save snapshot
    function saveSnapshot() {
      const content = editor.innerHTML; // Get the current content of the editor
      const now = new Date().toLocaleString(); // Get the current timestamp
      const snapshots = JSON.parse(localStorage.getItem(SNAPSHOT_KEY)) || []; // Retrieve existing snapshots or initialize an empty array
      snapshots.unshift({ name: `Snapshot - ${now}`, content }); // Add the new snapshot to the beginning of the array
      localStorage.setItem(SNAPSHOT_KEY, JSON.stringify(snapshots)); // Save the updated snapshots array to localStorage
      showToast("Snapshot saved"); // Show feedback to the user
    }

    // Export as .txt or .md
    function exportContent() {
      const text = editor.innerText;
      const html = editor.innerHTML;
      // Ask user for format
      const format = prompt('Export as .txt or .md? (type txt or md)', 'txt');
      if (!format) return;
      let blob, filename;
      if (format === 'md') {
        filename = 'omi.md';
        blob = new Blob([text], {type: 'text/markdown'});
      } else {
        filename = 'omi.txt';
        blob = new Blob([text], {type: 'text/plain'});
      }
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
      }, 100);
    }

    // Focus mode CSS (lighter, readable)
    const style = document.createElement('style');
    style.innerHTML = `body.focus-mode #word-count { display: none; } body.focus-mode { background: rgba(255,255,255,0.7) !important; color: #222 !important; }
    body.zen-mode #zen-overlay { background: rgba(255,255,255,0.7) !important; }`;
    document.head.appendChild(style);

    // Also auto-link and auto-markdown on paste and blur
    editor.addEventListener('paste', () => setTimeout(() => { autoLink(editor); autoMarkdown(editor); }, 0));
    editor.addEventListener('blur', () => { autoLink(editor); autoMarkdown(editor); });

    // Zen Mode
    function toggleZenMode() {
      const zenOverlay = document.getElementById('zen-overlay');
      const isZen = document.body.classList.toggle('zen-mode');
      zenOverlay.style.display = isZen ? 'block' : 'none';
      document.getElementById('word-count').style.display = isZen ? 'none' : '';
      timerMinimal.style.display = isZen && timerActive ? 'block' : (timerActive ? 'block' : 'none');
      statsMinimal.style.display = 'none';
      if (isZen) {
        editor.blur();
        setTimeout(() => editor.focus(), 100);
      }
    }
    // Exit Zen on Escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && document.body.classList.contains('zen-mode')) {
        toggleZenMode();
        toggleActiveCommand('zen', false);
      }
    });

    // Timer (minimal)
    let timerInterval = null;
    let timerActive = false;
    let timerEnd = null;
    let timerMins = null;
    function startTimer(mins) {
      stopTimer();
      timerActive = true;
      timerMins = mins;
      timerEnd = Date.now() + mins * 60 * 1000;
      timerMinimal.style.display = 'block';
      updateTimerMinimal();
      timerInterval = setInterval(updateTimerMinimal, 1000);
    }
    function stopTimer() {
      timerActive = false;
      timerMins = null;
      timerEnd = null;
      clearInterval(timerInterval);
      timerMinimal.style.display = 'none';
      updateActiveCommandsDisplay();
    }
    function updateTimerMinimal() {
      if (!timerActive || !timerEnd) return;
      let ms = timerEnd - Date.now();
      if (ms <= 0) {
        timerMinimal.textContent = " 00:00";
        setTimeout(stopTimer, 2000);
        showCopyToast('Timer finished!');
        return;
      }
      let mins = Math.floor(ms / 60000);
      let secs = Math.floor((ms % 60000) / 1000);
      timerMinimal.textContent = ` ${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }

    // Minimal stats
    let sessionStart = Date.now();
    function showStatsMinimal() {
      statsMinimal.style.display = 'block';
      updateStatsMinimal();
      setTimeout(() => { statsMinimal.style.display = 'none'; toggleActiveCommand('stats', false); }, 5000);
    }
    function updateStatsMinimal() {
      if (statsMinimal.style.display !== 'block') return;
      let sessionMs = Date.now() - sessionStart;
      let sessionMin = Math.floor(sessionMs / 60000);
      let sessionSec = Math.floor((sessionMs % 60000) / 1000);
      let today = new Date().toISOString().slice(0, 10);
      let dailyKey = 'omi-daily-' + today;
      let wordCount = editor.innerText.trim() ? editor.innerText.trim().split(/\s+/).length : 0;
      let goal = parseInt(localStorage.getItem('omi-goal') || '1000', 10);
      statsMinimal.innerHTML = `Session: ${sessionMin}m ${sessionSec}s<br>Today: ${wordCount} words<br>Goal: ${goal}`;
    }
    setInterval(updateStatsMinimal, 1000);

    // Active commands logic
    function toggleActiveCommand(cmd, on = null, arg = null) {
      if (on === null) {
        // toggle
        if (activeCommands.includes(cmd)) {
          activeCommands = activeCommands.filter(c => c !== cmd);
        } else {
          activeCommands.push(cmd);
        }
      } else if (on) {
        if (!activeCommands.includes(cmd)) activeCommands.push(cmd);
      } else {
        activeCommands = activeCommands.filter(c => c !== cmd);
      }
      updateActiveCommandsDisplay();
    }
    function updateActiveCommandsDisplay() {
      if (activeCommands.length === 0) {
        activeCommandsDiv.textContent = '';
        return;
      }
      let labels = activeCommands.map(cmd => {
        if (cmd === 'zen') return 'Zen mode';
        if (cmd === 'focus') return 'Focus mode';
        if (cmd === 'timer') return timerActive && timerMins ? `Timer (${timerMins}m)` : 'Timer';
        if (cmd === 'stats') return 'Stats';
        return cmd;
      });
      activeCommandsDiv.textContent = labels.join('  •  ');
    }

    // macOS-style caret logic
    function updateMacCaret() {
      if (document.activeElement !== editor) {
        editor.classList.remove('mac-caret-active');
        return;
      }
      const sel = window.getSelection();
      if (!sel.rangeCount) {
        editor.classList.remove('mac-caret-active');
        return;
      }
      const range = sel.getRangeAt(0).cloneRange();
      range.collapse(true);
      let rect = range.getClientRects()[0];
      if (!rect) {
        editor.classList.remove('mac-caret-active');
        return;
      }
      editor.classList.add('mac-caret-active');
      editor.style.setProperty('--mac-caret-x', rect.left + 'px');
      editor.style.setProperty('--mac-caret-y', rect.top + 'px');
      editor.style.setProperty('--mac-caret-height', rect.height + 'px');
      // Color is handled by CSS
    }
    editor.addEventListener('keyup', updateMacCaret);
    editor.addEventListener('mouseup', updateMacCaret);
    editor.addEventListener('input', updateMacCaret);
    editor.addEventListener('focus', updateMacCaret);
    editor.addEventListener('blur', () => editor.classList.remove('mac-caret-active'));
    document.addEventListener('scroll', updateMacCaret, true);
    window.addEventListener('resize', updateMacCaret);

    function clearEditorContent() {
      editor.innerHTML = ''; // Clear the editor content
      showToast("Editor content cleared."); // Show feedback
    }

    function loadSnapshots() {
      const snapshots = JSON.parse(localStorage.getItem(SNAPSHOT_KEY)) || []; // Retrieve existing snapshots

      console.log('Snapshots found:', snapshots); // Debugging line

      if (snapshots.length === 0) {
        showToast('No snapshots available'); // Show feedback if no snapshots exist
        return; // Exit if there are no snapshots
      }

      // Create dropdown
      const dropdown = document.createElement('div');
      dropdown.style.position = 'absolute';
      dropdown.style.background = '#fff'; // Match app background
      dropdown.style.borderRadius = '8px';
      dropdown.style.padding = '0.5rem';
      dropdown.style.zIndex = '1000';
      dropdown.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)'; // Slightly darker shadow for depth
      dropdown.style.maxHeight = '300px'; // Limit height for better usability
      dropdown.style.overflowY = 'auto'; // Enable scrolling if too many snapshots
      dropdown.style.width = '200px'; // Set a fixed width for consistency
      dropdown.style.fontFamily = 'inherit'; // Match app font
      dropdown.style.color = '#333'; // Darker text for readability

      dropdown.innerHTML = `<ul style="list-style: none; margin: 0; padding: 0;">${snapshots.map((snap, index) => {
        return `<li class="snapshotItem" onclick="revertToSnapshot(${index}, dropdown)">${snap.name}</li>`; // Create list items for each snapshot
      }).join('')}</ul>`;

      // Append dropdown to body
      document.body.appendChild(dropdown);
      console.log('Dropdown created and appended:', dropdown); // Debugging line

      // Position the dropdown
      const commandBar = document.getElementById('commandBar');
      const rect = commandBar.getBoundingClientRect();
      dropdown.style.top = `${rect.bottom + window.scrollY}px`;
      dropdown.style.left = `${rect.left + window.scrollX}px`;

      // Show the dropdown
      dropdown.style.display = 'block'; // Ensure dropdown is visible

      // Close dropdown on click outside
      document.addEventListener('click', (event) => {
        if (!dropdown.contains(event.target) && event.target !== commandBar) {
          dropdown.remove(); // Remove dropdown if clicked outside
        }
      });
    }

    let historySnapshots = [];

    function trackHistory() {
      const currentContent = editor.innerHTML;
      historySnapshots.push(currentContent);
      if (historySnapshots.length > 20) {
        historySnapshots.shift(); // Keep only the last 20 versions
      }
    }

    // Call trackHistory() on major changes or at intervals
    setInterval(trackHistory, 5 * 60 * 1000); // Every 5 minutes

    const dropdown = document.getElementById("copyDropdown");
    const toast = document.getElementById("toast");

    const copyFormats = ["Plain Text", "Markdown", "HTML", "Rich Text"];
    let selectedOptionIndex = -1; // Track the selected option index

    function toggleDropdown() {
      dropdown.innerHTML = "";
      copyFormats.forEach((format, index) => {
        const div = document.createElement("div");
        div.className = "option";
        div.textContent = format;
        div.onclick = () => {
          handleCopy(format);
          dropdown.style.display = "none";
          removeSlashCommand('/copy');
        };
        dropdown.appendChild(div);
      });
      dropdown.style.display = dropdown.style.display === "block" ? "none" : "block";
      positionDropdown();
      selectedOptionIndex = -1; // Reset selection
    }

    function positionDropdown() {
      const sel = window.getSelection();
      if (sel.rangeCount > 0) {
        const range = sel.getRangeAt(0);
        const rect = range.getBoundingClientRect();
        dropdown.style.top = `${rect.bottom + window.scrollY}px`;
        dropdown.style.left = `${rect.left + window.scrollX}px`;
      }
    }

    function updateDropdownSelection() {
      const options = dropdown.getElementsByClassName("option");
      for (let i = 0; i < options.length; i++) {
        options[i].classList.remove("selected");
      }
      if (selectedOptionIndex >= 0) {
        options[selectedOptionIndex].classList.add("selected");
      }
    }

    function handleCopy(format) {
      const content = editor.innerHTML;
      let output = content;

      if (format === "Plain Text") {
        output = editor.innerText;
        navigator.clipboard.writeText(output).then(() => {
          showToast("Copied as Plain Text");
          removeSlashCommand('/copy');
        }).catch(err => {
          console.error('Failed to copy: ', err);
        });
      } else if (format === "Markdown") {
        output = toMarkdown(content);
        navigator.clipboard.writeText(output).then(() => {
          showToast("Copied as Markdown");
          removeSlashCommand('/copy');
        }).catch(err => {
          console.error('Failed to copy: ', err);
        });
      } else if (format === "HTML") {
        navigator.clipboard.writeText(content).then(() => {
          showToast("Copied as HTML");
          removeSlashCommand('/copy');
        }).catch(err => {
          console.error('Failed to copy: ', err);
        });
      } else if (format === "Rich Text") {
        const blob = new Blob([content], { type: "text/html" });
        const item = new ClipboardItem({ "text/html": blob });
        navigator.clipboard.write([item]).then(() => {
          showToast("Copied as Rich Text");
          removeSlashCommand('/copy');
        }).catch(err => {
          console.error('Failed to copy: ', err);
        });
      }
    }

    function toMarkdown(html) {
      return html
        .replace(/<strong>(.*?)<\/strong>/g, '**$1**')
        .replace(/<em>(.*?)<\/em>/g, '*$1*')
        .replace(/<br\s*\/?>/g, '\n')
        .replace(/<\/p><p>/g, '\n\n')
        .replace(/<\/?[^>]+(>|$)/g, ''); // strip all other HTML
    }

    function showToast(message) {
      toast.textContent = message;
      toast.style.display = "block";
      setTimeout(() => {
        toast.style.display = "none";
      }, 2000);
    }

    // Revert to selected snapshot
    function revertToSnapshot(index, dropdown) {
      const snapshot = JSON.parse(localStorage.getItem(SNAPSHOT_KEY))[index];
      if (snapshot) {
        editor.innerHTML = snapshot.content;
        localStorage.setItem('omi-content', snapshot.content); // Update the main content
        showToast(`Loaded: ${snapshot.name}`); // Show feedback to the user

        // Remove the dropdown after selection
        if (dropdown) {
          dropdown.remove(); // Close the dropdown
        }

        // Remove the '/copy' command from the editor
        removeSlashCommand('/copy'); // Remove the command from the editor
      }
    }

    function handleCopyCommand() {
      const content = editor.innerHTML; // Get the current content of the editor
      const output = editor.innerText; // Default to Plain Text

      navigator.clipboard.writeText(output).then(() => {
        showToast("Copied as Plain Text");
        removeSlashCommand('/copy'); // Remove the command from the editor
      }).catch(err => {
        console.error('Failed to copy: ', err);
      });
    }

    // Clear all content and reset
    function clearAll() {
      editor.innerHTML = ''; // Clear the editor content
      localStorage.removeItem(SNAPSHOT_KEY); // Clear snapshots
      localStorage.removeItem('omi-content'); // Clear main content
      showToast("All content cleared and reset."); // Show feedback
    }
  </script>
  
  <script>
    window.SOLA_SITE_ID = "12u";
  </script>
  <script src="https://sola-three.vercel.app/sola.js" defer></script>
  
</body>
</html> 